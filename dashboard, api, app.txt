#dashboard.py
import streamlit as st
import sqlite3
import pandas as pd
import matplotlib.pyplot as plt

st.set_page_config(page_title="Dashboard", layout="wide")

st.title("Tracks Dashboard")

conn = sqlite3.connect('tracks.db')
query = "SELECT * FROM tracks"
df = pd.read_sql_query(query, conn)
conn.close()   

st.dataframe(df, use_container_width=True)
for track_name in df['track_name'].unique():
    track_data = df[df['track_name'] == track_name]
    
    st.subheader(track_name)
    
    fig, ax = plt.subplots(figsize=(10, 4))
    ax.plot(track_data['ele'])
    ax.set_ylabel('Elevation (m)')
    ax.set_xlabel('Point')
    ax.grid(True, alpha=0.3)
    
    st.pyplot(fig)

#api.py
from fastapi import FastAPI
from pydantic import BaseModel
import pandas as pd
import pickle
import uvicorn
from sklearn.preprocessing import LabelEncoder
import numpy as np

app = FastAPI(title="Route Risk API", version="1.0", description="API –¥–ª—è –ø—Ä–æ–≥–Ω–æ–∑–∏—Ä–æ–≤–∞–Ω–∏—è —Ä–∏—Å–∫–æ–≤ –Ω–∞ —Ç—É—Ä–∏—Å—Ç–∏—á–µ—Å–∫–∏—Ö –º–∞—Ä—à—Ä—É—Ç–∞—Ö")

with open('best_model.pkl', 'rb') as f:
    model = pickle.load(f)

le = LabelEncoder()
le.classes_ = np.array(['–í—ã—Å–æ–∫–∏–π', '–ù–∏–∑–∫–∏–π', '–°—Ä–µ–¥–Ω–∏–π'])

class Coordinates(BaseModel):
    lon: float
    lat: float
    ele: float
    temperature: float
    steps: float

@app.post("/risk", summary="–û—Ü–µ–Ω–∫–∞ —Ä–∏—Å–∫–∞ –ø–æ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞–º")
def get_risk(coords: Coordinates):
    features = pd.DataFrame([[coords.lon, coords.lat, coords.ele, coords.temperature, coords.steps]],
                           columns=['lon', 'lat', 'ele', 'temperature', 'steps'])
    prediction = model.predict(features)[0]
    risk_level = le.inverse_transform([prediction])[0]
    return {"risk_level": risk_level}

@app.post("/flood_forecast", summary="–ü—Ä–æ–≥–Ω–æ–∑ –∑–∞—Ç–æ–ø–ª–µ–Ω–∏—è –Ω–∞ 2035")
def flood_forecast(coords: Coordinates):
    future_features = pd.DataFrame([[coords.lon, coords.lat, coords.ele + 20, coords.temperature + 2.7, coords.steps]],
                                   columns=['lon', 'lat', 'ele', 'temperature', 'steps'])
    prediction = model.predict(future_features)[0]
    risk = le.inverse_transform([prediction])[0]
    return {"year": 2035, "flood_risk": risk}

@app.post("/fire_forecast", summary="–ü—Ä–æ–≥–Ω–æ–∑ –ø–æ–∂–∞—Ä–æ–æ–ø–∞—Å–Ω–æ—Å—Ç–∏ –Ω–∞ 2035")
def fire_forecast(coords: Coordinates):
    future_features = pd.DataFrame([[coords.lon, coords.lat, coords.ele, coords.temperature + 3.5, coords.steps]],
                                   columns=['lon', 'lat', 'ele', 'temperature', 'steps'])
    prediction = model.predict(future_features)[0]
    risk = le.inverse_transform([prediction])[0]
    return {"year": 2035, "fire_risk": risk}

@app.post("/evacuation", summary="–û—Ü–µ–Ω–∫–∞ —Å–ª–æ–∂–Ω–æ—Å—Ç–∏ —ç–≤–∞–∫—É–∞—Ü–∏–∏")
def evacuation_difficulty(coords: Coordinates):
    features = pd.DataFrame([[coords.lon, coords.lat, coords.ele, coords.temperature, coords.steps]],
                           columns=['lon', 'lat', 'ele', 'temperature', 'steps'])
    prediction = model.predict(features)[0]
    difficulty = le.inverse_transform([prediction])[0]
    return {"evacuation_difficulty": difficulty}

if __name__ == "__main__":
    uvicorn.run(app, host="127.0.0.1", port=8080)

#app.py
import streamlit as st
import pandas as pd
import folium
from streamlit_folium import folium_static
import requests
import gpxpy
from datetime import datetime

st.set_page_config(page_title="Route Risk Analysis", layout="wide")

st.title("üó∫Ô∏è –ê–Ω–∞–ª–∏–∑ —Ä–∏—Å–∫–æ–≤ —Ç—É—Ä–∏—Å—Ç–∏—á–µ—Å–∫–∏—Ö –º–∞—Ä—à—Ä—É—Ç–æ–≤")

with st.sidebar:
    st.header("üìã –°–ø—Ä–∞–≤–∫–∞")
    st.markdown("""
    **–ö–æ–º–∞–Ω–¥—ã:**
    - –í—ã–±–µ—Ä–∏—Ç–µ —Ç—Ä–µ–∫ –∏–∑ —Å–ø–∏—Å–∫–∞
    - –£–∫–∞–∂–∏—Ç–µ –¥–∞—Ç—É –ø—Ä–æ—Ö–æ–∂–¥–µ–Ω–∏—è
    - –ü—Ä–æ—Å–º–æ—Ç—Ä–∏—Ç–µ —Ä–∏—Å–∫–∏ –Ω–∞ –∫–∞—Ä—Ç–µ
    
    **–¶–≤–µ—Ç–∞:**
    - üî¥ –í—ã—Å–æ–∫–∏–π —Ä–∏—Å–∫
    - üü† –°—Ä–µ–¥–Ω–∏–π —Ä–∏—Å–∫
    - üü¢ –ù–∏–∑–∫–∏–π —Ä–∏—Å–∫
    """)

track_files = ["1.gpx", "2.gpx", "3.gpx"]
selected_track = st.selectbox("–í—ã–±–µ—Ä–∏—Ç–µ —Ç—Ä–µ–∫", track_files)
selected_date = st.date_input("–î–∞—Ç–∞ –ø—Ä–æ—Ö–æ–∂–¥–µ–Ω–∏—è", datetime.now())

if st.button("–ê–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å –º–∞—Ä—à—Ä—É—Ç"):
    with open(selected_track, 'r') as f:
        gpx = gpxpy.parse(f)
    
    points = []
    for track in gpx.tracks:
        for segment in track.segments:
            for point in segment.points:
                points.append({"lon": point.longitude, "lat": point.latitude, 
                             "ele": point.elevation, "temperature": 20, "steps": 100})
    
    df_track = pd.DataFrame(points)
    
    m = folium.Map(location=[df_track['lat'].mean(), df_track['lon'].mean()], zoom_start=13)
    colors = {'–í—ã—Å–æ–∫–∏–π': 'red', '–°—Ä–µ–¥–Ω–∏–π': 'orange', '–ù–∏–∑–∫–∏–π': 'green'}
    
    risk_counts = {'–í—ã—Å–æ–∫–∏–π': 0, '–°—Ä–µ–¥–Ω–∏–π': 0, '–ù–∏–∑–∫–∏–π': 0}
    errors = []
    
    for idx, row in df_track.iterrows():
        try:
            response = requests.post("http://127.0.0.1:8080/risk", 
                                    json={"lon": float(row['lon']), "lat": float(row['lat']), 
                                          "ele": float(row['ele']), "temperature": float(row['temperature']), 
                                          "steps": float(row['steps'])}, timeout=5)
            
            if response.status_code == 200:
                risk = response.json()['risk_level']
                risk_counts[risk] += 1
                folium.CircleMarker([row['lat'], row['lon']], radius=4, 
                                  color=colors[risk], fill=True, opacity=0.7).add_to(m)
            else:
                errors.append(f"–¢–æ—á–∫–∞ {idx}: HTTP {response.status_code}")
                folium.CircleMarker([row['lat'], row['lon']], radius=4, 
                                  color='gray', fill=True, opacity=0.5).add_to(m)
        except Exception as e:
            errors.append(f"–¢–æ—á–∫–∞ {idx}: {str(e)}")
            folium.CircleMarker([row['lat'], row['lon']], radius=4, 
                              color='gray', fill=True, opacity=0.5).add_to(m)
    
    col1, col2 = st.columns([2, 1])
    
    with col1:
        st.subheader("–ö–∞—Ä—Ç–∞ –º–∞—Ä—à—Ä—É—Ç–∞")
        folium_static(m, width=700, height=500)
    
    with col2:
        st.subheader("–ü—Ä–æ–≥–Ω–æ–∑ —Ä–∏—Å–∫–æ–≤")
        st.metric("üî¥ –í—ã—Å–æ–∫–∏–π —Ä–∏—Å–∫", f"{risk_counts['–í—ã—Å–æ–∫–∏–π']} —É—á–∞—Å—Ç–∫–æ–≤")
        st.metric("üü† –°—Ä–µ–¥–Ω–∏–π —Ä–∏—Å–∫", f"{risk_counts['–°—Ä–µ–¥–Ω–∏–π']} —É—á–∞—Å—Ç–∫–æ–≤")
        st.metric("üü¢ –ù–∏–∑–∫–∏–π —Ä–∏—Å–∫", f"{risk_counts['–ù–∏–∑–∫–∏–π']} —É—á–∞—Å—Ç–∫–æ–≤")
        
        total = sum(risk_counts.values())
        if total > 0:
            st.progress(risk_counts['–ù–∏–∑–∫–∏–π'] / total, text="–ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å –º–∞—Ä—à—Ä—É—Ç–∞")
        
        if errors:
            st.error(f"–û—à–∏–±–æ–∫: {len(errors)}")
            with st.expander("–ü–æ–∫–∞–∑–∞—Ç—å –æ—à–∏–±–∫–∏"):
                for error in errors[:5]:
                    st.text(error)

